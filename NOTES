(note that design notes appear in reverse-chronological order, each note
separated by a line of ---)

The "old design" below the --- is broken for how branch deletion works. If I
create a new branch and start commiting to it, the old branch gets deleted
automatically unless someone else immediately starts committing. The essence of
the problem is that trying to mirror the same set of branches on several peers
means we have to either disallow deletion and all changes except
fast-forwarding, or we have to keep timestamps for each branch and do our own
conflict resolution. Because neither of those two options are palatable, we'll
just only sync a single branch called "hesokr" among all peers, which has the
limitations of deletion being unsupported and only fast-forward updates
allowed.

All data is transferred between peers through git pushes. When pushing:
* third-party peer branches - which is any branch named *_hesokr_(HOST) where
  HOST is not me or the push destination peer, try to push to the same branch
  name, but if it fails, ignore it.
* hesokuri - try to push to the same branch name, but if it fails, force push to
  hesokuri_hesokr_(MY_HOSTNAME).
* local branch - which is any branch that is not hesokuri and not named in the
  form of *_hesokr_*, force push to (BRANCH_NAME)_hesokr_(MY_HOSTNAME)
This makes polling for changes between peers a little hard. We can decide later
whether to introduce a separate pinging protocol, or do pure git fetches.

--------------------------------------------------------------------------------

Old design:
All data is transferred between peers through git pushes. When pushing:
* third-party peer branches - try to push to the same branch name, but if it
  fails, ignore it.
* canonical branch - try to push to the canonical name. If it fails, do a forced
  push to (BRANCH_NAME)_hesokr_(MY_HOSTNAME)

When we get data pushed to us, detect it by monitoring filesystem activity in
.git. After it is detected, see if there is something actionable to do:
* If the working area is clean (no untracked files, no changed files, no staged
  changes) and (CURRENT_BRANCH)_hesokr_(PEER_NAME) is a fast-forward, move the
  branch to point to it, and make HEAD point to it also.
* For non-checked-out branch FOO_BRANCH, if (FOO_BRANCH)_hesokr_(PEER_NAME) is a
  fast-forward of FOO_BRANCH, move the branch head of FOO_BRANCH to point to it.
* For any two branches FOO and BAR, if BAR is a fast-forward of FOO, and BAR is
  a canonical branch or FOO is a non-canonical branch, delete the FOO branch.

--------------------------------------------------------------------------------
Let's use hostnames rather than MAC addresses. Hostnames can be configured by
the user so are more flexible. Try to avoid reinventing the wheel in regards to
discoverability of clients, etc.

Clojure seems like a good platform/language - it is a powerful language and has
all the library support that Java has. Supporting things like notifications and
running as a service will have to happen with non-JVM libraries and tools, but
the core can be JVM-based. Python is more popular than Clojure, but basically
has the same limitations when it comes to platform-specific richness, and is
less powerful language-wise.

Keep a database of what peers have each version of local branches. When one goes
out of date, immediately push changes, even if the client seems to not be
responding. If the peer is not responding and they have out of date branches,
try a ping every few minutes. If a peer is not responding but we know it has our
latest branches, do not bother it.

Listen for file changes in the git repo to know when a peer has pushed changes
to me. Then, if the branch is "inactive" locally, try to merge it in
automatically. If the merge results in conflicts, abort the merge and leave the
remote branch. If the merge is successful, delete the peer-generated branch.

A branch is inactive if it is not checked out (includes all branches in bare
repos) OR it is checked out and there are no local changes.

When pushing to a remote branch that has the current machine's host name
prepended to it, always force the push, which causes non-fast-forwards to
overwrite the exiting branch.

When pushing to a branch that doesn't have the current machine's host name,
never force. This means only fast-forwards to non-checked-out branches will
work.

Primarily, consider it the system's responsibility to push their own changes to
peers. (later we can add polling for some redundancy, if it seems necessary).
